---
title: "Public perceptions of multiple risks during the COVID-19 pandemic in Italy and Sweden. Reproducing original findings and extending it with data for Poland."
author: "Mateusz Bary≈Ça, Konrad Lewszyk"
date: "5/20/2022"
output: 
  html_document:
    theme: paper
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
bibliography: bibliography.bib
nocite: '@*'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```


```{r package installation and import, include = FALSE, echo = FALSE}
requiredPackages = c("groundhog")
for(i in requiredPackages){if(!require(i,character.only = TRUE)) install.packages(i)}
for(i in requiredPackages){if(!require(i,character.only = TRUE)) library(i,character.only = TRUE) }
pkgs <- c("fmsb", "stats", "tidyverse")
groundhog.library(pkgs,
                  date = "2022-05-22",
                  tolerate.R.version='4.1.1')
```

For our Reproducible Research class we decided to extend a survey based research. We chose a 2020 research on public perception on multiple risks during the COVID-19 pandemic in Italy and Sweden [@Werner2021], [@original_scripts]. In order to build upon the study, we replicated the survey questions from and gathered X new answers. We sent out the surveys to Polish citizens to extend the findings by another country, and then compare our findings with the findings of the researchers. It is important to remember the researchers conducted their study during the onset of the pandemic, while we reproduced and extended the research after the vaccination period and towards the end of the pandemic.

# 1. Downloading the data

The survey was performed in August and November 2020. Here, we replicate the results from the paper which means that we focus only on the first wave of the study.

```{r}
df <- read.csv("data/Dataset_round1_august2020.csv", header = TRUE, na = "999")

# Rename the columns for ease of use
colnames(df) <- c("INTNR", "gender", "age", "region_ita", "region_swe",
                  "lik_ep", "lik_fl", "lik_dr", "lik_wf", "lik_ea", "lik_ta", "lik_dv", "lik_ec", "lik_cc",
                  "dam_ep",  "dam_fl", "dam_dr", "dam_wf", "dam_ea", "dam_ta", "dam_dv", "dam_ec", "dam_cc",
                  "dam_oth_ep", "dam_oth_fl", "dam_oth_dr", "dam_oth_wf", "dam_oth_ea", "dam_oth_ta", "dam_oth_dv", "dam_oth_ec", "dam_oth_cc",
                  "prep_aut_ep", "prep_aut_fl", "prep_aut_dr", "prep_aut_wf", "prep_aut_ea", "prep_aut_ta", "prep_aut_dv", "prep_aut_ec", "prep_aut_cc",
                  "prep_ep", "prep_fl", "prep_dr", "prep_wf", "prep_ea", "prep_ta", "prep_dv", "prep_ec", "prep_cc",
                  "know_aut_ep", "know_aut_fl", "know_aut_dr", "know_aut_wf", "know_aut_ea", "know_aut_ta", "know_aut_dv", "know_aut_ec", "know_aut_cc",
                  "know_ep", "know_fl", "know_dr", "know_wf", "know_ea", "know_ta", "know_dv", "know_ec", "know_cc",
                  "exp_ep", "exp_fl", "exp_dr", "exp_wf", "exp_ea", "exp_ta", "exp_dv", "exp_ec", "exp_cc",
                  "edu", "income", "work", "sector", "pol", "weight", "area")

```


```{r}
# creates a factor with 2 levels (Italy = 1, Sweden = 2)
df$area2 <- ifelse(df$area == 1, 1,ifelse(df$area == 2, 1, 2))
df$area2 <- as.factor(df$area2) 

# here we exclude not needed columns
df_research <- df
not_needed_columns <- c("INTNR", "region_ita", "region_swe", "weight", "pol", "area")
df_research <- df_research %>% select(-not_needed_columns)
```

```{r}
df_dam <- df[, c(15:32, 85)] # takes only the columns needed for the chart
only_columns_for_chart <- df_dam %>% names()
```

We need to make sure the data we are obtaining from our Google Forms is compatible with the data format that of the researchers's data.

```{r Preprocessing and cleaning the data}
df_new <- read.csv("data/survey.csv", header = TRUE, na = "999")
not_needed_columns <- c("Timestamp")
df_new <- df_new %>% select(-not_needed_columns)

mapping_tibble <- readxl ::read_excel("data\\mapping_tibble.xlsx")

#converting names of columns to a convenient format
df_new <- df_new %>%
  rename_at(vars(as.character(mapping_tibble$our_names)),
            ~ as.character(mapping_tibble$original_names))

#ensuring our variables are characters
df_new <- df_new %>%
  mutate(across(everything(), as.character))

#converting our data to a long format
df_new_likert_longer <- df_new %>%
  mutate(nr_row = 1:nrow(.), .before = lik_ep) %>%
  select(nr_row:know_cc, sector, income) %>%
  pivot_longer(cols = -nr_row)

df_new_yes_no_longer <- df_new %>%
  mutate(nr_row = 1:nrow(.), .before = exp_ep) %>%
  select(nr_row:exp_cc) %>%
  pivot_longer(cols = -nr_row)

# no mapping for age
df_new_age <- df_new %>%
    select(age) %>%
    mutate(nr_row = 1:nrow(.))

# simple likert mapping
df_new_likert_mapped <- df_new_likert_longer %>%
  mutate(first_char = substr(value, 1, 2)) %>%
  mutate(first_char = str_trim(first_char)) %>%
  mutate(first_char = str_replace_all(first_char, "\\.", "")) %>%
  mutate(int_value = if_else(first_char %in% c("1", "2", "3", "4", "5"),
                             first_char, NULL)) %>%
  pivot_wider(id_cols = nr_row, names_from = name, values_from = int_value)

# other mapping
df_for_other_mapping <-
  df_new %>%
  mutate(nr_row = 1:nrow(.), .before = edu) %>%
  select(nr_row:gender, -income, -sector) %>%
  pivot_longer(cols = -nr_row)

values_mapping <- readxl::read_excel("Data/values_mapping.xlsx")

df_new_all <-
  df_for_other_mapping %>%
    left_join(values_mapping, on = "value") %>%
    pivot_wider(id_cols = nr_row, names_from = name, values_from =  int_value)

# simple yes/no mapping
df_new_yes_no_mapped <- df_new_yes_no_longer %>%
  left_join(values_mapping, on = "value") %>%
  distinct() %>%
  pivot_wider(id_cols = nr_row, names_from = name, values_from =  int_value)

df_new_all_cols <- df_new_yes_no_mapped %>%
  inner_join(df_new_likert_mapped, on = "nr_row") %>%
  inner_join(df_new_all, on = "nr_row") %>%
  inner_join(df_new_age, on = "nr_row")

# mapping all the values to integer
df_new_all_cols_int_mapped <- df_new_all_cols %>%
  select(-work) %>%
  mutate(across(everything(), as.numeric))
df_new_all_cols_int_mapped$area2 <-  3
df_new_all_cols_int_mapped$area2 <-  as.factor(df_new_all_cols_int_mapped$area2)
df_research_names <- df_research %>% names()
df_new_final <- df_new_all_cols_int_mapped %>%
  relocate(all_of(only_columns_for_chart))

df_extended <- bind_rows(df_research, df_new_final)
```

# 2. Functions

#### Functions {.tabset .tabset-pills}
Defining functions for data preparation and graphing

##### Specific column selection function
```{r}
#' Returns tibble with only necessary columns for aggregation.
#'
#' @param dataframe_to_derive_column_names A tibble based on which the necessary columns will be derived.
#' @param dataframe_to_modify A tibble that will be used for subsetting.
#' @param start index of the first column
#' @param end index of the last column
#' @return tibble only with columns between start and end indexes and an area column
derive_necessary_columns <- function(dataframe_to_derive_column_names, dataframe_to_modify, start, end){
  only_columns_for_chart <- dataframe_to_derive_column_names[,c(start:end, 85)] %>% names()
  
  final_dataframe <- dataframe_to_modify %>% select(all_of(only_columns_for_chart))
  return(final_dataframe)
}
```

##### Data aggregation function

```{r}
#' Returns tibble aggregated by the chosen variable.
#'
#' @param dataset A tibble based on which the necessary columns will be derived.
#' @param start index of the first column
#' @param end index of the last column
#' @param aggregating_variable the grouping column
#' @return aggregated tibble
aggregate_method <- function(dataset, start, end, aggregating_variable){
  return(aggregate(dataset[,start:end], by = list(aggregating_variable),
                   FUN = mean, na.rm = TRUE))
}
```


##### Specific country data preparation function
```{r}
#' Returns complete dataframe for a country, with the structure that is required by
#' by radarchart function from fmsb library.
#'
#' @param dataframe_1 First dataframe
#' @param dataframe_2 index of the first column
#' @param row_to_select index of the row to select from the final DataFrame
#' @param rowname_1 name of the first rowname
#' @param rowname_2 name of the second rowname
#' @return dataframe for the country
derive_dataframe_for_country <- function(dataframe_1, dataframe_2, row_to_select,
                                         rowname_1, rowname_2){
  colnames(dataframe_1) <- c("area", "Epidemics", "Floods", "Drought", "Wildfires", "Earthquakes",
                           "Terror attacks", "Domestic violence", "Economic crises", "Climate Change")
  colnames(dataframe_2) <- c("area", "Epidemics", "Floods", "Drought", "Wildfires", "Earthquakes",
                           "Terror attacks", "Domestic violence", "Economic crises", "Climate Change")
  df_to_return <- rbind(dataframe_1[row_to_select,], dataframe_2[row_to_select,])
  df_to_return <- df_to_return[,2:10]
  rownames(df_to_return) <- c(rowname_1, rowname_2)
  df_to_return <- rbind(rep(5,9) , rep(1,9) , df_to_return) #needed for creating radarchart successfully
  return(df_to_return)
}
```


##### Graphing function
```{r}
#' Plots the radarchart based on the provided DataFrame, with the given title,
#' The labels in the legend correspond to legend_1 and legend_2.
#'
#' @param dataframe dataframe that is required by radarchart function from fmsb library.
#' @param title title to put on the chart
#' @param legend_1 legend for the first froup
#' @param legend_2 legend for the second group
#' @return dataframe for the country
graph_radar <- function(dataframe, title, legend_1, legend_2){
  graph <- radarchart(dataframe,
             axistype = 1 ,
             #customize the polygons
             pcol = colors_border,
             #pfcol = , # for filling the polygons
             pty = 32,
             plwd = 2,
             plty = 1,
             #customize the grid
             cglcol = "grey",
             cglty = 1,
             axislabcol = "grey",
             caxislabels = seq(1,5,1),
             cglwd = 0.8,
             #custom labels
             vlcex = 0.9,
             title = title)
  legend(x = 1.5, y = 1, legend = c(legend_1, legend_2),
         bty = "n", pch = 20 , col = colors_border, text.width = 2, cex = 0.8, pt.cex = 2)
}
```

#### {-}

# 3. Data preparation for graphing

Based on the functions provided before we prepare all the DataFrames by applying simple commands.
As in the original research there will be three figures, for three dimensions presented below.

####  {.tabset .tabset-pills}

##### Damage
```{r}
df_dam <- derive_necessary_columns(df, df_extended, 15, 32)

df_dam_ind <- aggregate_method(df_dam, 1, 9, df_dam$area2)
df_dam_oth <- aggregate_method(df_dam, 10, 18, df_dam$area2)

df_dam_ita <- derive_dataframe_for_country(df_dam_ind, df_dam_oth, 1, "authorities", "respondent")
df_dam_swe <- derive_dataframe_for_country(df_dam_ind, df_dam_oth, 2, "authorities", "respondent")
df_dam_pol <- derive_dataframe_for_country(df_dam_ind, df_dam_oth, 3, "authorities", "respondent")
```


##### Preparedness
```{r}
df_prep <- derive_necessary_columns(df, df_extended, 33, 50)

df_prep_aut <- aggregate_method(df_prep, 1, 9, df_prep$area2)
df_prep_ind <- aggregate_method(df_prep, 10, 18, df_prep$area2)

df_prep_ita <- derive_dataframe_for_country( df_prep_ind, df_prep_aut, 1, "authorities", "respondent")
df_prep_swe <- derive_dataframe_for_country( df_prep_ind, df_prep_aut, 2, "authorities", "respondent")
df_prep_pol <- derive_dataframe_for_country( df_prep_ind, df_prep_aut, 3, "authorities", "respondent")
```

##### Knowledge
```{r}
df_know <- derive_necessary_columns(df, df_extended, 51, 68)

df_know_aut <- aggregate_method(df_know, 1, 9, df_know$area2)
df_know_ind <- aggregate_method(df_know, 10, 18, df_know$area2)

df_know_ita <- derive_dataframe_for_country( df_know_ind,df_know_aut, 1, "authorities", "respondent")
df_know_swe <- derive_dataframe_for_country( df_know_ind,df_know_aut, 2, "authorities", "respondent")
df_know_pol <- derive_dataframe_for_country( df_know_ind,df_know_aut, 3, "authorities", "respondent")
```

#### {-}

# 4. Graphing risk perception by country

The original findings are repeated for Italy and Sweden. We extend the research with responses from Poland.

####  Damage {.tabset .tabset-pills}

##### Italy
```{r}
colors_border <- c( "#b9de28ff", "#47972aff")
graph_radar(df_dam_ita, "Italy - Perceived impact of the following threats", 
            "on the respondent","on others in the country")
```


##### Sweden
```{r}
graph_radar(df_dam_swe, "Sweden - Perceived impact of the following threats",
            "on the respondent","on others in the country")
```

##### Poland
```{r}
graph_radar(df_dam_pol, "Poland - Perceived impact of the following threats",
            "on the respondent","on others in the country")
```

####  Preparedness {.tabset .tabset-pills}

##### Italy
```{r}
graph_radar(df_prep_ita, "Italy - Preparedness for the following threats",
            "of authorities","of the respondent")
```

##### Sweden
```{r}
graph_radar(df_prep_swe, "Sweden - Preparedness for the following threats", 
            "of authorities","of the respondent")
```

##### Poland
```{r}
graph_radar(df_prep_pol, "Poland - Preparedness for the following threats",
            "of authorities","of the respondent")
```

#### {-}

####  Knowledge {.tabset .tabset-pills}

##### Italy
```{r}
graph_radar(df_know_ita, "level of knowledge", 
            "authorities","individual")
```

##### Sweden
```{r}
graph_radar(df_know_swe, "level of knowledge", 
            "authorities","individual")
```

##### Poland
```{r}
graph_radar(df_know_pol, "level of knowledge", 
            "authorities","individual")
```

#### {-}

# Bibliography



